# [自定义函数](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Functions#自定义函数 "Permalink to 自定义函数")

您在过去的课程中还看到很多定制功能 - 在代码中定义的功能，而不是在浏览器中。每当您看到一个自定义名称后面都带有括号，那么您使用的是自定义函数。在我们的[循环文章中](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Looping_code)的[random-canvas-circles.html](https://mdn.github.io/learning-area/javascript/building-blocks/loops/random-canvas-circles.html)示例（另见完整的[源代码](https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/loops/random-canvas-circles.html)）中，我们包括一个如下所示的自定义函数：`draw()`

```js
function draw() {
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  for (var i = 0; i < 100; i++) {
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,0,0,0.5)';
    ctx.arc(random(WIDTH), random(HEIGHT), random(50), 0, 2 * Math.PI);
    ctx.fill();
  }
}
```

该函数在[元素与 canvas 脚本 API 来绘制图形和动画。">`<canvas>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas)元素中绘制 100 个随机圆。每次我们想要这样做，我们可以使用这个函数来调用这个功能

```js
draw();
```

而不是每次我们想重复一遍，都要写出所有的代码。函数可以包含任何您喜欢的代码 - 甚至可以从内部函数调用其他函数。以上函数例如调用`random()`函数三次，由以下代码定义：

```js
function random(number) {
  return Math.floor(Math.random()*number);
}
```

我们需要这个函数，因为浏览器的内置[Math.random（）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random)函数只生成一个 0 到 1 之间的随机十进制数。我们想要一个 0 到一个指定数字之间的随机整数。

## [调用函数](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Functions#调用函数 "Permalink to 调用函数")

现在你可能很清楚这一点，但仅仅为了防止……，要在函数定义之后，实际使用它，你必须运行或调用它。这是通过将函数名包含在代码的某个地方，后跟圆括号来完成的。

```js
function myFunction() {
  alert('hello');
}

myFunction();
// calls the function once
```

简单来说，这种函数只能 独词成行 使用

我知道你想干啥，你想自定义这些东西

```js
let randomNumber = Math.floor(Math.random() * 100) + 1;

const guesses = document.querySelector('.guesses');
```

是的，你想定义一个像 `document` 一样的“集”

真贪心，不过没关系，你可以搞个***类***，再用 `new` 构造化一个对象，这样就可以了，大家基本上都这么用。

## [new 做了什么事](https://juejin.cn/post/6844903876705927176)

```markdown
- 1.创建一个新的对象
- 2.设置新对象的constructor属性为构造函数的名称
- 3.对象的__proto__属性指向构造函数的prototype对象
- 4.使用新对象调用函数，函数中的this被指向新实例对象
- 5.返回这个新的对象
```

## [类和构造函数](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript#类和构造函数 "Permalink to 类和构造函数")

你可以使用 [`class`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class) 关键字声明一个类。下面是上一篇文章中关于 `Person` 类的一个声明：

```js
class Person {

  name;

  constructor(name) {
    this.name = name;
  }

  introduceSelf() {
    console.log(`Hi! I'm ${this.name}`);
  }

}
```

在这个 `Person` 类的声明中，有：

-   一个 `name` 属性。
-   一个需要 `name` 参数的构造函数，这一参数用于初始化新的对象的 `name` 属性。
-   一个 `introduceSelf()` 方法，使用 `this` 引用了对象的属性。

`name;` 这一声明是可选的：你可以省略它，因为在构造函数中的 `this.name = name;` 这行代码会在初始化 `name` 属性前自动创建它。但是，在类声明中明确列出属性可以方便阅读代码的人更容易确定哪些属性是这个类的一部分。

你也可以在声明属性时，为其初始化一个默认值。就像这样：`name = '';`。

构造函数使用 [`constructor`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor) 关键字来声明。就像[在类声明外的构造函数](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics)一样，它会：

-   创建一个新的对象
-   将 `this` 绑定到这个新的对象，你可以在构造函数代码中使用 `this` 来引用它
-   执行构造函数中的代码
-   返回这个新的对象

如上文中给出的类声明的代码，你可以像这样创建和使用一个新的 `Person` 实例：

```js
const giles = new Person('Giles');

giles.introduceSelf(); // Hi! I'm Giles
```

注意，我们使用类的名字来调用构造函数，即示例中的 `Person`。

```js
class Animal {

  sleep() {
    console.log('zzzzzzz');
  }

}

const spot = new Animal();

spot.sleep(); // 'zzzzzzz'
```

## [继承](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript#继承 "Permalink to 继承")

对于上文给出的 `Person` 类，我们声明一个它的子类 `Professor`。

```js
class Professor extends Person {

  teaches;

  constructor(name, teaches) {
    super(name);
    this.teaches = teaches;
  }

  introduceSelf() {
    console.log(`My name is ${this.name}, and I will be your ${this.teaches} professor.`);
  }

  grade(paper) {
    const grade = Math.floor(Math.random() * (5 - 1) + 1);
    console.log(grade);
  }

}
```

我们使用 [`extends`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends) 关键字来声明这个类继承自另一个类。

我们为 `Professor` 类添加了一个新的属性 `teaches`，就像声明的那样。

因为我们想在创建新的 `Professor` 时设置 `teaches`，我们需要声明一个需要 `name` 和 `teaches` 参数的构造函数。构造函数中需要做的第一件事是使用 [`super()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super) 调用父类的构造函数，并传递 `name` 参数。父类的构造函数会设置 `name` 属性。然后 `Professor` 的构造函数接着设置 `teaches` 属性。

**备注：** 如果子类有任何自己的初始化内容需要完成，它也**必须**先使用 `super()` 来调用父类的构造函数，并传递父类构造函数期望的任何参数。

我们还覆盖了父类的 `introduceSelf()` 方法，并添加了一个新的方法 `grade()`，来为论文打分（我们的教授不是很好，只是随意地为论文打分）。

有了这个声明，我们现在可以创建和使用 professor 实例了：

```js
const walsh = new Professor('Walsh', 'Psychology');
walsh.introduceSelf();  // 'My name is Walsh, and I will be your Psychology professor'

walsh.grade('my paper'); // some random grade
```

## [继承](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript#继承 "Permalink to 继承")

对于上文给出的 `Person` 类，我们声明一个它的子类 `Professor`。

```js
class Professor extends Person {

  teaches;

  constructor(name, teaches) {
    super(name);
    this.teaches = teaches;
  }

  introduceSelf() {
    console.log(`My name is ${this.name}, and I will be your ${this.teaches} professor.`);
  }

  grade(paper) {
    const grade = Math.floor(Math.random() * (5 - 1) + 1);
    console.log(grade);
  }

}
```

我们使用 [`extends`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends) 关键字来声明这个类继承自另一个类。

我们为 `Professor` 类添加了一个新的属性 `teaches`，就像声明的那样。

因为我们想在创建新的 `Professor` 时设置 `teaches`，我们需要声明一个需要 `name` 和 `teaches` 参数的构造函数。构造函数中需要做的第一件事是使用 [`super()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super) 调用父类的构造函数，并传递 `name` 参数。父类的构造函数会设置 `name` 属性。然后 `Professor` 的构造函数接着设置 `teaches` 属性。

**备注：** 如果子类有任何自己的初始化内容需要完成，它也**必须**先使用 `super()` 来调用父类的构造函数，并传递父类构造函数期望的任何参数。

我们还覆盖了父类的 `introduceSelf()` 方法，并添加了一个新的方法 `grade()`，来为论文打分（我们的教授不是很好，只是随意地为论文打分）。

有了这个声明，我们现在可以创建和使用 professor 实例了：

```js
const walsh = new Professor('Walsh', 'Psychology');
walsh.introduceSelf();  // 'My name is Walsh, and I will be your Psychology professor'

walsh.grade('my paper'); // some random grade
```

## [封装](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript#封装 "Permalink to 封装")

最后，让我们了解一下 JavaScript 中如何实现封装。在上一篇文章中，我们讨论了我们为什么想要使得 `Student` 的 `year` 属性变为私有的，我们可以在不破坏任何使用了 `Student` 类的代码的情况下，修改射箭课程的规则。

这里，就像我们之前想要的那样，声明了 `Student` 类：

```js
class Student extends Person {

  #year;

  constructor(name, year) {
    super(name);
    this.#year = year;
  }


  introduceSelf() {
    console.log(`Hi! I'm ${this.name}, and I'm in year ${this.#year}.`);
  }

  canStudyArchery() {
    return this.#year > 1;
  }

}
```

在这个类的声明中，`#year` 是一个[私有数据属性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Private_class_fields)。我们可以构造一个 `Student` 对象，然后在内部使用 `#year`，但如果在类的外部尝试访问 `#year`，浏览器将会抛出错误：

```js
const summers = new Student('Summers', 2);

summers.introduceSelf(); // Hi! I'm Summers, and I'm in year 2.
summers.canStudyArchery(); // true

summers.#year; // SyntaxError
```

私有数据属性必须在类的声明中声明，而且其名称需以 `#` 开头。

### [私有方法](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript#私有方法 "Permalink to 私有方法")

与私有数据属性一样，你也可以声明私有方法。而且名称也是以 `#` 开头，只能在类自己的方法中调用：

```js
class Example {

  somePublicMethod() {
    this.#somePrivateMethod();
  }

  #somePrivateMethod() {
    console.log('You called me?');
  }

}

const myExample = new Example();

myExample.somePublicMethod(); // 'You called me?'

myExample.#somePrivateMethod(); // SyntaxError
```

截取上段以提醒

```js
  somePublicMethod() {
    this.#somePrivateMethod();
  }
```